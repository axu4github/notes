# 《Solr实战》读书笔记

![](assets/markdown-img-paste-20170905151702579.png)

## 12.搭建Solr生产环境

### 12.3 硬件配置和服务器配置

#### 12.3.1 内存和固态硬盘

- `Solr`进行`分面`、`排序`、`索引文档`和`查询请求缓存`时会消耗大量内存。
- `Solr`索引能否完全载入当前服务器 **未分配** 给`JVM`的可用内存空间中。
- 在查询性能优化时，保证所有索引都能加载到内存中 比 使用`SSD`更好。
- 在索引性能优化时，替换`SSD`为更好的选择。

#### 12.3.2 JVM设置

- `JVM`内存空间只用来 存储核心数据结构（`缓存："主要由字段缓存、过滤器缓存、历史查询缓存组成"`、`Solr内核`和`其他内存数据结构`）和 执行查询操作。
- **必须不能分配太多的内存给JVM**，因为需要留下更多的系统内存用来存储索引数据。
- 如果要求在大多数时间里`Solr`都能达到最佳性能，并且允许某段时间长期地暂停服务（无响应），那么可以选择`吞吐垃圾回收器（Throughput Garbage Collector）`。
- 如果追求的是长时间稳定的性能，可以使用`并发标记清楚回收器（Concurrent Marksweep Garbage Collector）`。

（补充现在生产环境Solr启动配置）

#### 12.3.3 索引切换

##### 增量索引

- 索引创建遵循`增量索引`原则，即总是将修改添加到新文档中，而不添加到之前已写入文档中。
- `硬提交`操作会启动一个`新的搜索器`，`新的搜索器`会创建新的`索引（旧的索引块 + 新增的索引块）`。

##### 索引切换和缓存预热

- 在每一次提交时，`Solr`会`预热缓存（JVM中的缓存）`，即从`旧的搜索器`中将`缓存（JVM缓存包括：历史查询、过滤器、字段值等）`移动至`新的搜索器`中。

（补充缓存配置说明）

- `缓存`的大小越大，则`新搜索器`需要预热的时间就越久，创建索引的时间越长。
- `autowarmCount`值越高，创建索引时间越久（在对于`filterCache`配置中，如果有许多非常耗资源的过滤器，可能需要数分钟甚至是数小时才能完成一个新搜索器的预热）
- `autowarmCount`值过低，可能会对新搜索器的初始性能产生负面影响。

##### 索引块合并与优化

- 合并策略取决于`合并调度器（Merge Scheduler）`和`合并策略（Merge Policy）`决定何时以及如何合并索引。
- `mergeFactor`的值（或者`maxMergeAtOnce`和`segmentsPerTier`的值）越大则索引效率越高。
- `mergeFactor`的值（或者`maxMergeAtOnce`和`segmentsPerTier`的值）越小则检索效率越高。
- `optimize`在索引不再发生变化的时候使用。
- `optimize`时需要更多的系统资源（需要2倍的当前索引存储空间）。

#### 12.3.4 实用Solr系统配置技巧

##### 在启动前将索引加载到非JVM分配内存中

> **注意：** 在Solr未启用时并且系统内存大于Solr索引存储量时使用。

```bash
> find ${SOLR_INSTALL}/example/solr/*/data/ -type f -exec cat {} \; > /dev/null
```

### 12.4 数据获取策略

##### 文档格式、索引时间和批量更新

- 向`Solr`直接发送二进制格式的文档，可以减少创建索引时的序列化时间。
- 创建索引解析`XML`文件会消耗更多的资源，使用二进制或者`CSV`格式等易于解析的文档输入格式会在很大程度上减少索引时间。
- 索引过程一个最大的性能瓶颈是从外部数据库中加载内容，并将它转化为`Solr`的文档。

##### 利用 Solr Cell 从非文本文档中抽取文本数据

- 可以使用`Solr Cell`从`PDF, Word, Excel, PowerPoint, 图像`等其他常见格式中抽取文本。
- 可以在`Solr Cell`的Wiki页面中查看介绍。（ https://wiki.apache.org/solr/ExtractingRequestHandler ）

### 12.5 分片和复制

#### 12.5.1 分片策略

##### 文档总数

- 由于底层`lucene`的限制，`Solr`中限制了每个索引最大包含`2的31次方 (约21亿)`个文档。

## 参数说明

### 索引块合并与优化

```xml
<!-- solrconfig.xml -->
<!-- 若TieredMergePolicy没有被单独设置，则该值为mergeFactor的值（默认值也为10） --->
<mergePolicy class="org.apache.lucene.index.TieredMergePolicy">
  <!--  决定了一次最多有多少索引块可以被合并到新索引块中，默认情况下，这两者的值都被设为10。-->
  <int name="maxMergeAtOnce">10</int>
  <!--  决定了在solr开始合并索引块之前，可以创建多少个索引块。 -->
  <int name="segmentsPerTier">10</int>
</mergePolicy>

<!--
  该值或者（maxMergeAtOnce和segmentsPerTier）值越大，增创建索引的速度越快。
  推荐/默认值为10.
-->
<mergeFactor>10</mergeFactor>

<!-- solr根据上述规则完成索引块合并时，会将其中的旧数据（已删除的数据）清除，从而释放存储空间。 -->
```

### 复制配置

（需要添加复制配置说明）
